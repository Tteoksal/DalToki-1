TTeok
=====

TTeok(떡)은 SGML의 문법을 개량한 객체 지향 프로그래밍 페러다임을 가진 언어입니다.

---------------------------------------
  
## TTeok-2018 standard document

떡 언어의 2018년 표준 문서입니다.

#### 목차

1. 떡 언어란.
2. 표준안 제작 방식
3. 값과 타입
    1. 원시값과 타입
        1. 숫자 값
        2. 숫자 타입
        3. 문자 타입
        5. null 값
        6. null 타입
    2. 인공값과 타입
        1. 객체 값
        2. 객체 타입
        3. 인터페이스 값
        4. 인터페이스 타입
        4. 컨테이너 타입
        5. 리스트 값
        6. 리스트 타입
4. 구문
    1. 식별자
    2. 연산자
        1. typeof 연산자
    3. 리터럴
        1. 숫자 리터럴
        2. null 리터럴
        3. 객체 리터럴
        4. 문자 리터럴
        5. 문자열 리터럴
        6. 리스트 리터럴
        7. 인터페이스 리터럴
        8. 컨테이너 리터럴
            1. 속성
            2. 자식 컨테이너
            3. 컨테이너 체이닝
5. 예외
    1. SyntaxException
    2. TypeException
    3. RuntimeException
6. 추상 명세서 타입
    1. 레코드
    2. 리스트
7. 추상 명령
    1. ToNumberType ( variable )
    2. ToCharType ( variable )
    3. ToNullType ( variable )
    4. ToCharType ( variable )
    5. ToNullType ( variable )
    6. ToObjectType ( variable )
    7. ToClassType ( variable )
    8. ToContainerType ( variable )
    9. ToListType ( variable )
8. 변수 구현
9. Execution context
10. 모듈 작성
11. 알고리즘
12. EBNF 표기

---------------------------------------

### 1 떡 언어란

떡 언어는 HTML의 문법으로 프로그래밍을 할 수는 없을까? 라는 
의문에서부터 시작된 프로젝트입니다.
플렛폼으로는 데스크탑/브라우저를 지원할 예정입니다.

---------------------------------------

### 2 표준안 제작 방식

떡의 표준안은 서재원(EnvironmentSet)과 전상완(maxswjeon)이 기획, 제작하였습니다.
표준안의 요청은 풀 리퀘스트를 통해 요청안을 제출하시면 다른 컨트리뷰터들과 충분한 협의 시간을 가진 후
표준안 위원회의 과반수 이상의 동의를 받으면 다음 해 표준에 추가됩니다.

---------------------------------------

### 3 값과 타입

떡 언어에서 값은 원시값과 인공값 두 종류가 있습니다.
타입은 값을 표현하는 방식입니다. 같은 값 1을 가지고 있는 변수라 할지라도 타입에 따라 다르게 표현됩니다.
떡에서, 값과 타입은 변수에 담겨있습니다.
특정 타입은 특정 값들과만 같은 변수 내에 있을 수 있습니다. 이를 타입-값 관계라고 합니다.
타입-값 관계는 Table 1에 명시되어 있습니다.

Table 1

| 타입\값 | 숫자 값 | null 값 | 객체 값 | 인터페이스 값 | 리스트 값 |
|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| 숫자 타입 | 가능 | 가능 | 불가능 | 불가능 | 불가능 |
| 문자 타입 | 가능  | 가능 | 가능 | 가능 | 가능 |
| null 타입 | 가능 | 가능 | 가능 | 가능 | 가능 |
| 객체 타입 | 불가능 | 가능 | 가능 | 불가능 | 가능 |
| 인터페이스 타입 | 불가능 | 가능 | 가능 | 가능 | 불가능 |
| 컨테이너 타입 | 불가능 | 가능 | 가능 | 불가능 | 불가능 |
| 리스트 타입 | 불가능 | 가능 | 불가능 | 불가능 | 가능 |

// TODO : 빈 컨테이너에 대한 논의 필요.

#### 3.i 원시값과 타입

원시 값은 불변성을 가진 값을 의미합니다.
원시 타입은 원시값을 표현하는 형식입니다.

##### 3.i.a 숫자 값

떡에서, 숫자 크기 제한은 없습니다.
숫자 값은 담긴 변수의 타입이 명시되지 않았을 때, 숫자 타입을 가지게 만듭니다. 
    
    <var name = `number` type  = `typeof 0`>
        1234
    </>  
   
##### 3.i.b 숫자 타입

숫자 타입은 숫자 값을 표현하는 형식입니다.
값에 접근할 때 변수의 값을 숫자로 형 변환을 한 후 변수의 값으로서 전달해줍니다.
숫자 타입은 담긴 변수의 값이 초기화 되지 않았을 때 숫자 값 0을 기본값으로서 할당합니다.

    <var name = `number` type = `typeof 0`/> 
    
##### 3.i.c 문자 타입

문자 타입은 숫자 값을 문자로 표현하는 형식입니다.
값을 담은 변수의 타입을 문자로 바꾸면 값에 접근할 때 
변수의 값을 숫자로 형 변환을 한 후 UTF-8 코드에서 해당하는 문자를 변수의 값으로서 전달해줍니다.
문자 타입은 담긴 변수의 값이 초기화 되지 않았을 때 숫자 값 20을 기본값으로서 할당합니다.

    <var name = `char` type  = `typeof '' `/>
    
##### 3.i.d null 값

null 값은 빈 값을 의미합니다. 읽기와 쓰기, 원시 타입으로의 변환 연산을 제외한 다른 연산을 시도하면 
TypeException 예외를 일으킵니다.
null 값은 담긴 변수의 타입이 명시되지 않았을 때, null 타입을 가지게 만듭니다.

     <var name = `null` type  = `typeof null`>
        null
     </>
    
##### 3.1.e null 타입

null 타입은 빈 값을 표현하는 형식입니다.
변수의 값에 무엇이 들어있든 값에 접근할 때 null을 변수의 값으로서 전달해줍니다.
null 타입은 담긴 변수의 값이 초기화 되지 않았을 때 null 값을 기본값으로서 할당합니다.

     <var name = `null` type  = `typeof null`/>   

#### 3.ii 인공값과 타입

인공값은 내부적으로 가변성을 가진 값을 의미합니다.
인공 타입은 인공값을 표현하는 형식입니다. 

##### 3.ii.a 객체 값

객체는 프로퍼티(속성)의 집합으로 프로퍼티는 이름과 값으로 구성되어 있습니다. 
프로퍼티의 값으로는 변수가 들어갈 수 있습니다. 
프로퍼티의 이름으로는 식별자만이 가능합니다.
객체는 담긴 변수의 타입이 명시되지 않았을 때, 객체 타입을 가지게 만듭니다.

    <var name = `object`/>
        (x : 1, y : (z : 'a') )
    </>
  
##### 3.ii.b 객체 타입

객체 타입은 객체 값을 표현하는 형식입니다.프로퍼티에 프로퍼티 이름을 통한 접근을 제공해줍니다.
객체 타입은 담긴 변수의 타입이 명시되지 않았을 때, 빈 객체 값을 가지게 만듭니다.
객체 값의 구조(형태)는 곧 객체의 타입입니다.
    
    <var name = `object`/>
        (x : 1, y : (z : 'a') )
    </>
    # typeof (x : typeof 0, y : typeof(z : typeof '') ) 이게 위 객체의 구조이자 타입입니다. 
  
##### 3.ii.c 인터페이스 값

인터페이스 값은 컨테이너들의 집합입니다.
인터페이스 값은 담긴 변수의 타입이 명시되지 않았을 때 빈 인터페이스 값을 가지게 만듭니다.

    <var name = `interface` >
        { name = `method1` args = `()` },
        { name = `method2` args = `typeof 0, typeof '' ` }
    </>

##### 3.ii.d 인터페이스 타입

인터페이스 타입은 인터페이스 값을 표현하는 형식입니다.
특정 인터페이스 값에 정의된 컨테이너들을 구현하고 있는 객체값은 특정 인터페이스 타입으로도 취급할 수 있습니다.
인터페이스 타입은 담긴 변수의 값이 초기화 되지 않았을 때 빈 인터페이스 값 {} 을 기본값으로서 할당합니다. 

    <var name = `interface` >
            { name = `method1` args = `()` },
            { name = `method2` args = `typeof 0, typeof '' ` }
    </>
    <var name = `impl` >
        (
            method1 : <function name = `method1` args = ``>
                #something awesome
                </>,
            method2 : <function name = `method2` args = `typeof (x : typeof 0, y : typeof '')` >
                #something awesome2 
                </>    
        )
    </>
      
##### 3.ii.e 컨테이너 타입

컨테이너 타입은 객체로 표현된 컨테이너를 표현하는 타입입니다.
모든 컨테이너는 객체로 표현되어 있습니다.
인터페이스 타입은 담긴 변수의 값이 초기화 되지 않았을 때 객체 값( @head : typeof \[typeof \[typeof "", typeof null\]\], @body : typeof \[typeof null\] )을 기본값으로서 할당합니다.
변수의 값이 초기화가 되어있는 경우에는 @head : typeof \[typeof \[typeof "", typeof null\]\], @body : typeof \[typeof null\] 를 요소로써 객체 값에 추가합니다.
@head에는 문자열 : 값 형식으로 컨테이너 헤드가 표현됩니다. 
@body에는 값들의 리스트로 컨테이너 바디가 표현됩니다.

    <var name = `container1` type = `typeof <container></>` />
// TODO : 빈 컨테이너에 대한 논의 필요.    
##### 3.ii.f 리스트 값

리스트 값(이하 리스트)은 열거 가능한 값들의 연속입니다. 값으로는 떡의 값이 들어갈 수 있습니다.
리스트는 담긴 변수의 타입이 명시되지 않았을 때, 리스트 타입을 가지게 만듭니다.

    
    
##### 3.ii.g 리스트 타입

리스트 타입은 리스트를 표현하는 형식입니다.
기본값은 빈 리스트 []입니다.
리스트의 형태는 하나의 타입입니다.

    <var type  = `%list`/> 

---------------------------------------    
### 4 구문 

#### 4.i 주석

주석은 구현체가 낱말 분석 단계에서 무시하는 줄을 의미합니다.
\# 뒤부터 줄의 끝 부분까지는 낱말 분석 단계에서 소스코드로 취급하지 않고 제거합니다.

#### 4.i 식별자

식별자는 알파벳과 숫자,%,@,_로 이루어진 문자들의 열입니다. 식별자의 제일 앞 문자는 무조건 
숫자가 아닌 유효한 문자여야 합니다.

EBNF 표기는 아래와 같습니다.
    
    alphabet ::= A-Za-z
    character ::= alphabet|@|_|%
    integer ::=  0|1|2|3|4|5|6|7|8|9
    identifier ::= character "{" character | integer "}"
    
#### 4.ii 연산자

##### 4.ii.a typeof 연산자    
    
#### 4.iii 리터럴
    
리터럴은 값을 문자로 표현하는 방식입니다.
리터럴은 하나의 익명 변수입니다.

##### 4.iii.a 숫자 리터럴

숫자 리터럴은 숫자 값을 문자로 표현하는 방식입니다.
10진수 표기법으로 표기한 숫자는 모두 숫자 리터럴로 간주됩니다..

    <var name = `num_literal` type = `%number` value = `1` />
    #여기서 1이 숫자 리터럴입니다.

EBNF 표기는 아래와 같습니다.

     integer ::=  0|1|2|3|4|5|6|7|8|9
     number ::= integer "[" .integer "]"
     
##### 4.iii.b null 리터럴

null 리터럴은 null 값을 문자로 표현하는 방식입니다.
아래와 같이 알파벳 n,u,l,l을 연속해서 사용한 것이 null 리터럴로 간주됩니다.

    <var name = `null_literal` type = `%null` value = `null` />
    #여기서 null이 null 리터럴입니다.    
    
##### 4.iii.c 객체 리터럴

객체 리터럴은 객체 값을 문자로 표현하는 방식입니다.
( 프로퍼티 이름 : 값 또는 타입, ... ) 형식으로 표현한 것은 객체 리터럴로 간주됩니다.

    <var name = `object_literal` type = `%object` value = `(x : 1, y : 2)` />
    #여기서 (x : 1, y : 2)이 객체 리터럴입니다.
    
EBNF 표기는 아래와 같습니다.

    type ::= %number | %char | %null | %object | %class | %function | %list
    value ::= object | number | null | list | string | char
    element ::= "[" identifier : "(" value | type ")" "]"
    elements ::= element "[" , element "]"
    object ::= ( "[" elements "]" )
    
##### 4.iii.d 문자 리터럴        

문자 리터럴은 문자 타입을 가진 숫자 값을 표현하는 방식입니다.
'로 둘러쌓인 UTF8에서 지원하는 문자는 문자 리터럴로 간주됩니다.
    
    <var name = `char_literal` type = `%char` value = ` 'A' ` />
    #여기서 A가 문자 리터럴입니다.
    #변수 A의 값은 A의 utf-8 인코딩 값인 41이 되고, 타입은 문자 타입이 됩니다.
    
EBNF 표기는 아래와 같습니다.

    char ::= ' "{" UTF8Char "}" '
    
##### 4.iii.e 문자열 리터럴

문자열 리터럴은 문자 타입을 가진 숫자 값이 담긴 리스트 값을 문자로 표현하는 방식입니다.
"" 로 둘러쌓인 문자는 문자열 리터럴로 간주됩니다.

    <var name = `string_literal` type = `list` value = ` "Hello" ` />
    #여기서 Hello가 문자열 리터럴입니다.
    #NOTE : "Hello" 는 [ 'H', 'e', 'l', 'l', 'o' ] 와 같습니다.
    
EBNF 표기는 아래와 같습니다.

    string ::= " "{" UTF8Char "}" "
    
##### 4.iii.f 리스트 리터럴

리스트 리터럴은 리스트 값을 문자로 표현하는 방식입니다.
\[값 또는 타입, ...\] 형식으로 표현한 것은 리스트 리터럴로 간주됩니다.

    <var name = `list_literal` type = `list` value = `[ 1,%null,'A' ]` />
    #[ 1,%null,'A' ]이 리스트 리터럴입니다.
    
EBNF 표기는 아래와 같습니다.

    list ::= [ "[" elements "]" ]
    
##### 4.iii.g 인터페이스 리터럴

인터페이스 리터럴은 인터페이스 값을 문자로 표현하는 방식입니다.
{ name = \`메서드명\` args = \`(인자명 : 타입)\` }, ... 형식으로 표현한 것은 인터페이스 리터럴로 간주합니다.

    interface ::= { name = `identifier` args = `object` }
    interfaces ::= interface "[" , interface "]"
#### 4.iii.h 컨테이너 리터럴

컨테이너 리터럴은 컨테이너 타입을 가진 객체 값을 문자로 표현하는 방식입니다.
컨테이너는 컨테이너 헤드와 컨테이너 바디, 컨테이너 테일 로 이루어져 있습니다.

    <container-head>
        #container-body
    </> #container tail 
    
컨테이너 바디는 생략 가능합니다.

    <container-head>
    </> #container tail
    
또한 컨테이너 헤드와 컨테이너 tail 을 합칠 수 있습니다. 이를 싱글 컨테이너 라고 부릅니다.
이 경우에는 컨테이너 바디를 작성할 수 없습니다.

    <container-perfect />
각 컨테이너 바디는 자신의 렉시컬 스코프를 갖습니다.

    <container-head>
        <var name = `a` type = `number` />
    </> // a의 수명이 끝나고 가비지 컬렉팅 대상이 되서 처리됨.
    #변수 a에 접근 불가능
    
EBNF 표기는 아래와 같습니다.
    
    option ::= identifier = ` value `
    options ::= option "{" , option "}"
    containerBody ::= "{" container "}"
    containerHead ::= identifier "[" options "]" containerTail
    containerTail ::= /> | > containerBody </ "(" > | containerHead ")"
    container ::= < containerHead

###### 4.iii.h.a 속성

속성은 컨테이너의 특징, 상태 등을 기술하는 용도로 사용됩니다.
속성이름 = \`값\` 형식으로 기술합니다.
컨테이너 헤드에는 그 컨테이너의 속성을 기술할 수 있습니다.

    <container-head property1 = ` 123 ` />
    
EBNF 표기는 아래와 같습니다.

    option ::= identifier = ` value `
    options ::= option "{" , option "}"
    
###### 4.iii.h.b 자식 컨테이너

컨테이너 바디에는 다른 컨테이너들을 넣을 수 있습니다. 이 컨테이너들을 자식 컨테이너라고 부릅니다.
자식 컨테이너들은 부모 컨테이너의 일부입니다.

EBNF 표기는 아래와 같습니다.

    containerBody ::= "{" container "}"
    
###### 4.iii.h.c 컨테이너 체이닝

//스코프 확장 설명.
   
---------------------------------------

### 5. 예외

예외는 구현체가 코드를 해석, 실행하는 도중에 발생하는 문제들을 안내하는 방식입니다.
예외가 발생하면, 구현체는 예외를 출력하고 모든 작업을 중지합니다.

#### 5.i SyntaxException

SyntaxException은 낱말 분석 및 구문 분석 도중 문법을 어긴 코드를 발견했을 때 발생하는 예외입니다.
이 예외를 출력할 때에는 <SyntaxException in \[문법을 어긴 줄\]:\[전체 코드에서의 줄\] \[에러 메시지\] > 형식으로 출력합니다.

#### 5.ii TypeException

TypeException는 실행 도중 타입에서 정의되지 않은 동작을 하였을 때 발생하는 예외입니다.
또한 property 속성으로 정의된 객체의 뼈대를 어겼을 때, 함수의 인자로 잘못된 타입의 변수를 주었을 떄,
Table 1에 타입-값 관계 표를 어겼을 때 발생합니다.
이 예외를 출력할 때에는 <TypeException in \[문법을 어긴 줄\]:\[전체 코드에서의 줄\] \[에러 메시지\] > 형식으로 출력합니다.

#### 5.iii RuntimeException

RuntimeException은 실행 도중 잘못된 참조, 존재하지 않는 변수에 연산 시도 등 잘못된 코드에 의해 발생합니다.
이 예외를 출력할 때에는 <RuntimeException in \[문법을 어긴 줄\]:\[전체 코드에서의 줄\] \[에러 메시지\] > 형식으로 출력합니다.

---------------------------------------

### 6. 추상 명세서 타입

#### 6.i 레코드

레코드는 떡 구현체에서 사용하는 추상 자료형입니다.
프로퍼티의 집합으로, 프로퍼티는 이름 : 값으로 구성되어 있습니다.
프로퍼티의 이름은 \[\[\]\] 로 둘러쌓여 있습니다.
레코드는 아래와 같이 표현합니다. 

    Record { [[key]] : value, ... }

또한 레코드의 값은 아래와 같이 접근합니다.

    Record.[[key]]
    
#### 6.ii 리스트

리스트는 떡 구현체에서 사용하는 추상 자료형입니다.
값들의 배열로, 아래와 같이 표현합니다.

    List [ value, ... ]

---------------------------------------

### 7. 추상 명령

추상 명령은 구현체 내부에서 떡 언어를 구현하기 위해 사용되는 명령의 추상적 형태입니다.

### 8. 변수 구현

변수는 Table 2에 명시된 레코드로 구현됩니다.

Table 2

| 이름 | 값 | 용도 |
|:--------:|:--------:|:--------:|
| \[\[type\]\] | 변수의 타입 | 변수의 타입을 알기 위한 값 |
